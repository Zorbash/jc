-*- html -*-
JC


@author Jim Rosenblum <jrosenblum@carelogistics.com>
@copyright 2013-2015 Jim Rosenblum
@version v0.9.0
@title Welcome to JCache

@doc 
== JC == 
==Erlang, Distributable, In-Memory Cache==

=== Pub/Sub, Serialization Assist, JSON-Query Support and Simple Edn-based Binary Protocol for Interoperability ===
===Features===
<ul>
<li>Cache entries are Map, Key, Value, [TTL], [Sequence]
<ul>
<li>Maps represent a name-space for Keys - similar to the notion
of ‘bucket’
in other caching systems</li>
<li>{Map, Key} must be unique</li>
<li>Maps, Keys and Values can be any Erlang term</li>
<li>TTL is time-to-live in seconds</li>
</ul>
</li>
<li>Consistency Assist through Serialization: An alternative API
allows for a sequence-number parameter on the put/x, evict/x,
match/x and remove/x operations. Operations whose sequence
number is lower than the current, per-map max are disallowed
thereby ensuring, for example, that stale puts do not
overwrite fresher ones due to the fresh one beating the stale
one to the cache.</li>
<li>JSON Query Support</li>
<li>Query by JSON: When Values are JSON, evict_match/2,
evict_all_match/1 and values_match/2 can search or evict
keys whose JSON value, at a location specificed by a java-style, dot-path
string equals the specified value. That is,
jc:values_match(bed, “id.type=3”) would return all values for Keys in the
bed Map whose JSON value was an object with an “id”:3 in the top-level.</li>
<li>Ad-hoc, Index Support: In order to support faster
operations, (2-3 orders of magnitude), each map can have up to four,
dot-path, strings configured for which jc will provide
index support.</li>
<li>Auto Index Recognition - Ability to detect frequently used
JSON querries and automatically start indexing on them.</li>
<li>User Controlled Eviction
<ul>
<li>Map-level TTL: A job runs at configured intervals and removes
items whose create-date is older than a map-specific, configured
number of seconds.</li>
<li>Item-level TTL: PUTS can include a TTL which defines when the
item should be evicted. Used for shorter TTLs, as an exception
to a Map-level TTL, or when more precision is required than
offered by the Map-level TTL.</li>
</ul>
</li>
<li>Pub/Sub
<ul>
<li>Clients can subscribe to Map events for a specific key or
any key and for write, delete or either operations</li>
<li>Clients can create and subscribe to arbitrary 'topic’s and
broadcast arbitrary messages under those topic names</li>
</ul>
</li>
<li>Interopability: Edn-based binary protocol over TCP
<ul>
<li>Edn strings can be used over TCP to communicate with cache functionality.
Edn strings -&gt; binary -&gt; TCP &lt;- binary &lt;- Edn strings</li>
</ul>
</li>
<li>Bridge process that accepts messages from a client indicating
cache operations, executes the cache operations and returns the
results to the client. This has been used with JInterface to
interoperate with CLOJURE and Java clients</li>
<li>Fine-grained logging via lager</li>
</ul>
===Cache Functions (jc)===
<ul>
<li>Create
<ul>
<li>put(Map, Key, Value, [TTLSecs]) -&gt; {ok, {key, Key}} | {error, badarg}</li>
<li>put_all(Map, [{K,V},{K,V},…], [TTLSecs]) -&gt; {ok, {cnt, CntSuccessfulPuts}} |
{error, badarg}</li>
</ul>
</li>
<li>Delete
<ul>
<li>evict(Map, Key) -&gt; ok</li>
<li>evict_all_match(Criteria = “Json.Path.Match=Value”) -&gt; ok</li>
<li>evict_map_since(Map, Age_In_Secs) -&gt; ok</li>
<li>evict_match(Map, Criteria = “Json.Path.Match=Value”) -&gt; ok</li>
<li>remove_items(Map, Keys) -&gt; {ok, [{K, V}, …]} for each {K, V} deleted.</li>
</ul>
</li>
<li>Retrieve
<ul>
<li>get(Map, Key) -&gt; {ok, {value, Value}} | miss</li>
<li>get_all(Map, [K1, K2, …]) -&gt; {ok, {Found=[{K1,V1},…], Misses=[K2,…]}}</li>
<li>key_set(Map) -&gt; {ok, [K1, K2, …]} for each Key in the Map</li>
<li>values(Map) -&gt; {ok, [V1, V2, …]} for each Value in the Map</li>
<li>values_match(Map, Criteria=“JSon.Path.Match=Value”) -&gt;
{ok, [{K1,V1}, {K2,V2}, …]}</li>
</ul>
</li>
<li>Flush
<ul>
<li>clear(Map) -&gt; ok</li>
<li>flush() -&gt; ok</li>
<li>flush(silent) -&gt; ok &lt;-- Does not send alerts to subscribers</li>
</ul>
</li>
<li>Predicates
<ul>
<li>contains_key(Map, Key) -&gt; true | false.</li>
</ul>
</li>
<li>Meta
<ul>
<li>cache_nodes() -&gt; {nodes, {active, [Node1,… ]},
{configured, [Node1,… ]}}</li>
<li>cache_size() -&gt; {sizes, [{TableName, RecordCnt, Words}],…}</li>
<li>map_size(Map) -&gt; {records, Count}</li>
<li>maps() -&gt; {maps, [Map1, Map2,…]}</li>
<li>up() -&gt; {uptime, [{up_at, String},{now, String},
{up_time, {D, {H, M, S}}}]</li>
</ul>
</li>
</ul>
<h3><a id="Searializable_Cache_Functions_jc_s_96"></a>Searializable Cache Functions (jc_s)</h3>
<p>Identical to the Create and Evict family of functions above, except:</p>
<ul>
<li>Additional sequence parameter which is expected to be a monotonically
increcing integer (with respect to a given Map) which is used to disalow
“out of sequence” operations</li>
<li>Functions return {error, out_of_seq} if one attemts an out of sequence
operation
<ul>
<li>evict(Map, Key, Seq)</li>
<li>evict_all_match(Criteria = “Json.Path.Match=Value”, Seq)</li>
<li>evict_match(Map, Criteria = “Json.Path.Match=Value”, Seq)</li>
<li>put(Map, Key, Value, [TTLSecs], Seq)</li>
<li>put_all(Map, [{K,V},{K,V},…], [TTLSecs], Seq)</li>
<li>remove_items(Map, Keys, Seq)</li>
</ul>
</li>
<li>Meta Functions
<ul>
<li>sequence() -&gt; {sequences, [{Map, Highest_Number},… ]}</li>
<li>sequence(Map) -&gt; {sequence, Hightest_Number} | {ok, not_exist}</li>
</ul>
</li>
</ul>
===Eviction Manager Functions (jc_eviction_manager)===
<ul>
<li>set_max_ttl(Map, Secs) -&gt; ok | {error, badarg}</li>
<li>get_max_ttls() -&gt; {ttls, [{Map, Secs}, …]}</li>
</ul>
===Pub/Sub Functions (jc_psub)===
<ul>
<li>map_subscribe(Pid, Map, Key|any, write|delete|any) -&gt; ok |
{error, badarg}
<ul>
<li>client will receive
<ul>
<li>{map, key, delete}, or</li>
<li>{map, key, write, value}</li>
</ul>
</li>
</ul>
</li>
<li>map_unsubscribe(Pid, Map, Key|any, write|delete|any) -&gt; ok |
{error, badarg}</li>
<li>topic_subscribe(Pid, Topic, Value) -&gt; ok | {error, badarg}
<ul>
<li>client will receive {Topic, Value}</li>
</ul>
</li>
<li>topic_unsubscribe(Pid, Topic, Value) -&gt; ok | {error, badarg}</li>
<li>topic_event(Topic, Value) -&gt; ok. &lt;-- Broadcasts Value to all
subscribers of Topic</li>
</ul>
===Indexing Functions (jc_store)===
<ul>
<li>start_indexing(Map, Path={bed,&quot;<a href="http://menu.id">menu.id</a>&quot;}) -&gt; ok |
{error, no_indexes_available} |
{error, Term}</li>
<li>stop_indexing(Map, Path={bed,“menu”,“id”}) -&gt; ok</li>
<li>indexes(Map) -&gt; [{{Map, Path}, Position},…] for all indexes
of given Map</li>
<li>indexes() -&gt; [{{Map, Path}, Position},…] for all indexes</li>
</ul>
===Bridge Functions (jc_bridge)===
<ul>
<li>
<p>All functions from the jc, jc_s, jc_eviction_manager, jc_psub
and jc_store are supported and are of the form:</p>
<p><code>{From, {Fn, P1, P2,...}}</code></p>
<p>for each paramater, as in</p>
<p><code>jc_bridge ! {Pid, {put, Map, Key, Value}}</code></p>
</li>
<li>
<p>Additionally,</p>
<p>{From, {node_topic_sub}} -&gt; ok | {error, badarg},
client will recieve:</p>
<p><code>{jc_node_events, {nodedown, DownedNode, [ActiveNodes],[ConfiguredNodes]}}</code></p>
<p>or</p>
<p><code>{jc_node_events, {nodeup, UppedNode, [ActiveNodes],[ConfiguredNodes]}}</code></p>
<p>{From, {node_topic_unsub}} -&gt; ok.</p>
</li>
</ul>
<h3><a id="Interoperability_Ednbased_protocol_169"></a>Interoperability: Edn-based protocol</h3>
<p>The protocol utilizes Edn, a string-based data notation – see <a href="https://github.com/edn-format/edn">https://github.com/edn-format/edn</a>. UTF-8 Edn strings, binary encoded over TCP.</p>
<p>The protocol defines two message types CONNECT and COMMAND which are
binary strings consisting of an 8-byte size prefix followed by the
CONNECT or COMMAND details.</p>
<p>Responses are also binary strings with an 8-byte size prefix.</p>
<p>The CONNECT command initiates a session,</p>
<pre><code>M = &lt;&lt;&quot;(:connect {:version 1.0})&quot;&gt;&gt;
</code></pre>
<p>Size is 25, so the CONNECT message is:</p>
<pre><code>&lt;&lt;25:8, M/binary&gt;&gt; = 
&lt;&lt;25,40,58,99,111,110,110,101,99,116,32,123,58,118,101,
  114,115,105,111,110,32,49,46,48,125,41&gt;&gt;
</code></pre>
<p>The server will respond to a CONNECT command with either an error or
the encode version of {:version 1.0}</p>
<pre><code>&lt;&lt;13:8, {:version 1.0}/binary&gt;&gt; = 
&lt;&lt;13,123,118,101,114,115,105,111,110,32,49,46,48,125&gt;&gt;
</code></pre>
<p>COMMAND messages consist of an 8 bytes prefix  followed by the command.</p>
<p>NOTICE THAT KEYWORDS IN EDN will be convereted to atoms for erlang. Thus,
Module and Function names must be Edn keywords. The form of a command
message must be an Edn list with keywords specifying the desired Module
and function, as in: (:module, :fn (args))</p>
<pre><code>(:jc :put (:evs 1 &quot;a string value&quot;))
</code></pre>
<p>A client session might look as follows</p>
<pre><code>client:send(&quot;(:jc :put (:evs 1 \&quot;a string value\&quot;))&quot;).
==&gt; {:key 1}

client:send(&quot;(:jc :get (:evs 1))&quot;).
==&gt; {:value &quot;a string value&quot;}
</code></pre>
<p>Edn commands map directly to cache functions with the exception of the
jc_psub subscription functions which do NOT need a self() parameter since
the per-session, tcp listener is the process which subscribes. So:</p>
<pre><code>client:send(&quot;(:jc_psub :map_subscribe (:evs :any :any))&quot;).
===&gt; ok
</code></pre>
<p>upon an update to the evs map, the client receives,</p>
<pre><code>{:map_event {:map :evs :key 1 :op delete}}
{:map_event {:map :evs :key 1 :op write :value :1}}
</code></pre>
===Configuration===
<ul>
<li>Application configuration is in sys.config which is heavily
commented</li>
<li>Cookie, node-name and auto-restart of VM controlled by vm.args</li>
</ul>
===Application Modules===
<ul>
<li>jc_cluster
<ul>
<li>Simple, mnesia-based, cluster creation and management</li>
</ul>
</li>
<li>jc, jc_s, jc_store, jc_eviction_manager
<ul>
<li>Caching operations, Key-specific and Map-level TTLs</li>
</ul>
</li>
<li>jc_sequence
<ul>
<li>Singleton service enforcing strictly monotonic sequence
numbers on jc_s operations</li>
</ul>
</li>
<li>jc_analyzer
<ul>
<li>Analysis and indexing inititation of JSON query strings</li>
</ul>
</li>
<li>jc_protocol, jc_edn
<ul>
<li>Erlang -&gt; Edn and protocol modules</li>
</ul>
</li>
<li>jc_psub:
<ul>
<li>Pub / Sub of cache write and delete events</li>
<li>On-demand, ad-hoc topic events</li>
<li>Predefined, <em>jc_node_events</em> topic provides subscribers
node-up and node-down notifications</li>
</ul>
</li>
<li>jc_bridge
<ul>
<li>Server that acts as a proxy between an external process and
jc functionality</li>
</ul>
</li>
</ul>
===Build Instructions===
<ul>
<li>
<p>Ensure that Erlang 17 or higher is installed</p>
</li>
<li>
<p>Get the Source Code from Stash</p>
<p><code>[root@db01] git clone https://github.com/jr0senblum/jc.git</code></p>
</li>
<li>
<p>Edit the sys.config and vm.args files in ./config</p>
<ul>
<li>
<p>vm.args: Indicate the correct node names and cookie</p>
</li>
<li>
<p>sys.config: Adjust prarameters as neccesary.</p>
<p><code>[root@db01] ./rebar3 release</code></p>
<p>or</p>
<p><code>[root@db01] ./rebar3 prod release</code></p>
</li>
</ul>
</li>
</ul>
===Documentation===
<p><code>[root@dbo1] ./rebar3 edoc</code></p>

