-*- html -*-
JC


@author Jim Rosenblum <jrosenblum@carelogistics.com>
@copyright 2013-2015 Jim Rosenblum
@version v0.9.0
@title Welcome to JCache

@doc 
== JC == 
== Erlang, Distributable, In-Memory Cache with Pub/Sub, Serialization Assist and JSON-Query Support ==
===Features===
<ul>
<li>Cache entries are Map, Key, Value, [TTL], [Sequence]
<ul>
<li>Maps represent a name-space for Keys - similar to the notion
of ‘bucket’
in other caching systems</li>
<li>{Map, Key} must be unique</li>
<li>Maps, Keys and Values can be any Erlang term</li>
<li>TTL is time-to-live in seconds</li>
</ul>
</li>
<li>Consistency Assist through Serialization: An alternative API
allows for a sequence-number parameter on the put/x, evict/x,
match/x and remove/x operations. Operations whose sequence
number is lower than the current, per-map max are disallowed
thereby ensuring, for example, that stale puts do not
overwrite “fresh” ones because the “fresh” one beat the stale
one to jc.</li>
<li>JSON Query Support
<ul>
<li>Query by JSON: When Values are JSON, evict_match/2,
evict_all_match/1 and values_match/2 can search or evict
keys whose values match a java-style, dot-path, string
(i.e., “id.type=3”)</li>
<li>Ad-hoc, Index Support: In order to support faster
operations, (2-3 orders of magnitude), each map can have up to four,
dot-path, strings configured for which jc will provide
index support.</li>
<li>Auto Index Recognition - Ability to detect frequently used
JSON querries and automatically start indexing on them.</li>
</ul>
</li>
<li>User Controlled Eviction
<ul>
<li>Map-level TTL: A job runs at configured intervals and removes
items whose create-date is older than a map-specific, configured
number of seconds.</li>
<li>Item-level TTL: PUTS can include a TTL which defines when the
item should be evicted. Used for shorter TTLs, as an exception
to a Map-level TTL, or when more precision is required than
offered by the Map-level TTL.</li>
</ul>
</li>
<li>Pub/Sub
<ul>
<li>Clients can subscribe to Map events for a specific key or
any key and for write, delete or either operations</li>
<li>Clients can create and subscribe to arbitrary 'topic’s and
broadcast arbitrary messages under those topic names</li>
</ul>
</li>
<li>Bridge process that accepts messages from a client indicating
cache operations, executes the cache operations and returns the
results to the client. This has been used with JInterface to
interoperate with CLOJURE and Java clients</li>
<li>Fine-grained logging via lager</li>
</ul>
<p>###Cache Functions (jc)</p>
<ul>
<li>Create
<ul>
<li>put(Map, Key, Value, [TTLSecs]) -&gt; {ok, {key, Key}} | {error, badarg}</li>
<li>put_all(Map, [{K,V},{K,V},…], [TTLSecs]) -&gt; {ok, CntSuccessfulPuts}|{error, badarg}</li>
</ul>
</li>
<li>Delete
<ul>
<li>evict(Map, Key) -&gt; ok</li>
<li>evict_all_match(Criteria = “Json.Path.Match=Value”) -&gt; ok</li>
<li>evict_map_since(Map, Age_In_Secs) -&gt; ok</li>
<li>evict_match(Map, Criteria = “Json.Path.Match=Value”) -&gt; ok</li>
<li>remove_items(Map, Keys) -&gt; {ok, [{K, V}, …]} for each {K, V} deleted.</li>
</ul>
</li>
<li>Retrieve
<ul>
<li>get(Map, Key) -&gt; {ok, Value} | miss</li>
<li>get_all(Map, [K1, K2, …]) -&gt; {ok, {Found=[{K1,V1},…], Misses=[K2,…]}}</li>
<li>key_set(Map) -&gt; {ok, [K1, K2, …]} for each Key in the Map</li>
<li>values(Map) -&gt; {ok, [V1, V2, …]} for each Value in the Map</li>
<li>values_match(Map, Criteria=“JSon.Path.Match=Value”) -&gt; {ok, [{K1,V1}, {K2,V2}, …]}</li>
</ul>
</li>
<li>Flush
<ul>
<li>clear(Map) -&gt; ok</li>
<li>flush() -&gt; ok</li>
<li>flush(silent) -&gt; ok &lt;-- Does not send alerts to subscribers</li>
</ul>
</li>
<li>Predicates
<ul>
<li>contains_key(Map, Key) -&gt; true | false.</li>
</ul>
</li>
<li>Meta
<ul>
<li>cache_nodes() -&gt; {nodes, {active, [Node1,… ]},
{configured, [Node1,… ]}}</li>
<li>cache_size() -&gt; {size, [{TableName, RecordCnt, Words}],…}</li>
<li>map_size(Map) -&gt; {records, Count}</li>
<li>maps() -&gt; [Map1, Map2,…]</li>
<li>up() -&gt; {uptime, [{up_at, String},{now, String},
{up_time {D, {H, M, S}}}]</li>
</ul>
</li>
</ul>
<h3><a id="Searializable_Cache_Functions_jc_s_85"></a>Searializable Cache Functions (jc_s)</h3>
<p>Identical to the standard, CRUD functions above, except that</p>
<ul>
<li>Additional sequence parameter which is expected to be a monotonically
increcing integer which is used to disalow “out of sequence” operations</li>
<li>Functions return {error, out_of_seq} if one attemts an out of sequence
operation
<ul>
<li>evict(Map, Key, Seq)</li>
<li>evict_all_match(Criteria = “Json.Path.Match=Value”, Seq)</li>
<li>evict_match(Map, Criteria = “Json.Path.Match=Value”, Seq)</li>
<li>put(Map, Key, Value, [TTLSecs], Seq)</li>
<li>put_all(Map, [{K,V},{K,V},…], [TTLSecs], Seq)</li>
<li>remove_items(Map, Keys, Seq)</li>
</ul>
</li>
<li>Meta Functions
<ul>
<li>sequence() -&gt; {ok, [{Map, Highest_Number},… ]}</li>
<li>sequence(Map) -&gt; {ok, Hightest_Number} | {ok, not_exist}</li>
</ul>
</li>
</ul>
<p>###Eviction Manager Functions (jc_eviction_manager)</p>
<ul>
<li>set_max_ttl(Map, Secs) -&gt; ok | {error, badarg}</li>
<li>get_max_ttls() -&gt; [{Map, Secs}, …]</li>
</ul>
<p>###Pub/Sub Functions (jc_psub)</p>
<ul>
<li>map_subscribe(Pid, Map, Key|any, write|delete|any) -&gt; ok |
{error, badarg}
<ul>
<li>client will receive
<ul>
<li>{map, key, delete}, or</li>
<li>{map, key, write, value}</li>
</ul>
</li>
</ul>
</li>
<li>map_unsubscribe(Pid, Map, Key|any, write|delete|any) -&gt; ok |
{error, badarg}</li>
<li>topic_subscribe(Pid, Topic, Value) -&gt; ok | {error, badarg}
<ul>
<li>client will receive {Topic, Value}</li>
</ul>
</li>
<li>topic_unsubscribe(Pid, Topic, Value) -&gt; ok | {error, badarg}</li>
<li>topic_event(Topic, Value) -&gt; ok. &lt;-- Broadcasts Value to all
subscribers of Topic</li>
</ul>
<p>###Indexing Functions (jc_store)</p>
<ul>
<li>start_indexing(Map, Path={bed,&quot;<a href="http://menu.id">menu.id</a>&quot;}) -&gt; ok |
{error, no_indexes_available} |
{error, Term}</li>
<li>stop_indexing(Map, Path={bed,“menu”,“id”}) -&gt; ok</li>
<li>indexes(Map) -&gt; [{{Map, Path}, Position},…] for all indexes
of given Map</li>
<li>indexes() -&gt; [{{Map, Path}, Position},…] for all indexes</li>
</ul>
<p>###Bridge Functions (jc_bridge)</p>
<ul>
<li>
<p>All functions from the jc, jc_s, jc_eviction_manager, jc_psub
and jc_store are supported and are of the form:</p>
<p><code>{From, {Fn, P1, P2,...}}</code></p>
<p>for each paramater, as in</p>
<p><code>jc_bridge ! {Pid, {put, Map, Key, Value}}</code></p>
</li>
<li>
<p>Additionally,</p>
<p>{From, {node_topic_sub}} -&gt; ok | {error, badarg},
client will recieve:</p>
<p><code>{jc_node_events, {nodedown, DownedNode, [ActiveNodes],[ConfiguredNodes]}}</code></p>
<p>or</p>
<p><code>{jc_node_events, {nodeup, UppedNode, [ActiveNodes],[ConfiguredNodes]}}</code></p>
<p>{From, {node_topic_unsub}} -&gt; ok.</p>
</li>
</ul>
<p>###Application Modules</p>
<ul>
<li>jc_cluster
<ul>
<li>Simple, mnesia-based, cluster creation and management</li>
</ul>
</li>
<li>jc, jc_s, jc_store, jc_eviction_manager
<ul>
<li>Caching operations, Key-specific and Map-level TTLs</li>
</ul>
</li>
<li>jc_sequence
<ul>
<li>Singleton service enforcing strictly monotonic sequence
numbers on jc_s operations</li>
</ul>
</li>
<li>jc_analyzer
<ul>
<li>Analysis and indexing inititation of JSON query strings</li>
</ul>
</li>
<li>jc_psub:
<ul>
<li>Pub / Sub of cache write and delete events</li>
<li>On-demand, ad-hoc topic events</li>
<li>Predefined, <em>jc_node_events</em> topic provides subscribers
node-up and node-down notifications</li>
</ul>
</li>
<li>jc_bridge
<ul>
<li>Server that acts as a proxy between an external process and
jc functionality</li>
</ul>
</li>
</ul>
<p>###Configuration</p>
<ul>
<li>Application configuration is in sys.config which is heavily
commented</li>
<li>Cookie, node-name and auto-restart of VM controlled by vm.args</li>
</ul>
<p>###Build Instructions</p>
<ul>
<li>
<p>Ensure that Erlang 17 or higher is installed</p>
</li>
<li>
<p>Get the Source Code from Stash</p>
<p><code>[root@db01] git clone https://github.com/jr0senblum/jc.git</code></p>
</li>
<li>
<p>Edit the sys.config and vm.args files in ./config</p>
<ul>
<li>
<p>vm.args: Indicate the correct node names and cookie in
vm.args</p>
</li>
<li>
<p>sys.config: Adjust prarameters as neccesary.</p>
<p><code>[root@db01] ./rebar3 release</code></p>
<p>or</p>
<p><code>[root@db01] ./rebar3 prod release</code></p>
</li>
</ul>
</li>
</ul>
<p>###Documentation</p>
<p><code>[root@dbo1] ./rebar3 edoc</code></p>

